<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Khora Resource Tracking — Unit Tests</title>
<style>
  body { font-family: 'SF Mono', 'Fira Code', monospace; background: #0a0a0f; color: #e0e0e0; padding: 24px; line-height: 1.7; }
  h1 { font-size: 18px; color: #5ee4d6; margin-bottom: 20px; }
  h2 { font-size: 14px; color: #5b9cf5; margin-top: 24px; margin-bottom: 8px; border-bottom: 1px solid #222; padding-bottom: 4px; }
  .pass { color: #4ade80; } .fail { color: #f87171; } .skip { color: #fbbf24; }
  .test { margin: 4px 0; font-size: 12px; }
  .summary { margin-top: 24px; padding: 12px 16px; border-radius: 6px; font-size: 13px; font-weight: 600; }
  .summary.ok { background: rgba(74,222,128,.1); border: 1px solid rgba(74,222,128,.2); color: #4ade80; }
  .summary.fail { background: rgba(248,113,113,.1); border: 1px solid rgba(248,113,113,.2); color: #f87171; }
  pre { background: #111; padding: 8px 12px; border-radius: 4px; overflow-x: auto; font-size: 11px; color: #aaa; }
</style>
</head>
<body>
<h1>Khora Resource Tracking — Unit Tests</h1>
<div id="output"></div>

<script>
// ═══════════════════════════════════════════════════════════════════
// Extracted constants and functions from index.html for testing.
// These mirror the production code exactly.
// ═══════════════════════════════════════════════════════════════════

const NS = 'io.khora';

const RESOURCE_CATEGORIES = [
  'housing', 'financial', 'transportation', 'food', 'health',
  'employment', 'legal', 'education', 'general',
];

const RESOURCE_OPACITY = {
  SOVEREIGN:   0,
  ATTESTED:    1,
  CONTRIBUTED: 2,
  PUBLISHED:   3,
};

const RESOURCE_RELATION_TYPES = [
  'operates', 'funds', 'refers_to', 'contributes_to', 'transfers',
];

const RESOURCE_ALLOC_STATUSES = ['active', 'consumed', 'expired', 'revoked'];
const RESOURCE_LIFECYCLE_EVENTS = ['allocated', 'consumed', 'expired', 'revoked', 'returned'];
const RESOURCE_DEDUP_STATUSES = ['confirmed', 'attested_non_additive', 'unresolved'];
const RESOURCE_DEDUP_LINK_TYPES = ['subset', 'same', 'overlaps'];

function genResourceId(prefix) {
  return `${prefix}_${Date.now().toString(36)}${Math.random().toString(36).slice(2,8)}`;
}

function buildResourceSource(level, propagation, adoptedVia, proposedBy, originOrg) {
  const src = { level };
  if (level === 'network' && propagation) src.propagation = propagation;
  if (adoptedVia) src.adopted_via = adoptedVia;
  if (proposedBy) src.proposed_by = proposedBy;
  if (originOrg) src.origin_org = originOrg;
  src.adopted_at = Date.now();
  return src;
}

function buildConstraintGovernance(sourceLevel, propagation, adoptedVia, divergenceAllowed) {
  return {
    propagation: propagation || 'optional',
    adopted_via: adoptedVia || null,
    source_level: sourceLevel || 'org',
    divergence_allowed: divergenceAllowed !== false,
  };
}

function validateAllocation(allocationData, resourceType, policies, existingAllocations, callerRole) {
  const violations = [];

  const constraints = { ...(resourceType.constraints || {}) };
  for (const policy of (policies || [])) {
    if (policy.resource_type_id === resourceType.id) {
      Object.assign(constraints, policy.constraints || {});
    }
  }

  // CHECK 1: eligible_roles
  if (constraints.eligible_roles && constraints.eligible_roles.length > 0) {
    if (!constraints.eligible_roles.includes(callerRole)) {
      violations.push({
        check: 'eligible_roles',
        message: `Role '${callerRole}' is not authorized to allocate this resource. Authorized roles: ${constraints.eligible_roles.join(', ')}`,
        governance: constraints.governance || null,
      });
    }
  }

  // CHECK 2: max_per_client
  if (constraints.max_per_client != null) {
    const periodMs = (constraints.period_days || 365) * 24 * 60 * 60 * 1000;
    const cutoff = Date.now() - periodMs;
    const activeCount = (existingAllocations || []).filter(a =>
      a.resource_type_id === resourceType.id &&
      a.allocated_to === allocationData.allocated_to &&
      a.status === 'active' &&
      a.allocated_at >= cutoff
    ).length;
    if (activeCount + 1 > constraints.max_per_client) {
      violations.push({
        check: 'max_per_client',
        message: `Client already has ${activeCount} active allocation(s) of ${resourceType.name} within the ${constraints.period_days || 365}-day period (max: ${constraints.max_per_client})${constraints.governance?.adopted_via ? `, adopted via ${constraints.governance.adopted_via}` : ''}`,
        governance: constraints.governance || null,
      });
    }
  }

  // CHECK 3: requires_approval
  if (constraints.requires_approval) {
    const needsApproval = constraints.approval_threshold
      ? (allocationData.quantity * 1) > constraints.approval_threshold
      : true;
    if (needsApproval && !allocationData.approval) {
      violations.push({
        check: 'requires_approval',
        message: `This allocation requires approval${constraints.approval_threshold ? ` (amount exceeds threshold of ${constraints.approval_threshold})` : ''}. Approver roles: ${(constraints.approver_roles || ['admin']).join(', ')}`,
        governance: constraints.governance || null,
      });
    }
  }

  return { valid: violations.length === 0, violations };
}

// ═══════════════════════════════════════════════════════════════════
// Minimal test harness
// ═══════════════════════════════════════════════════════════════════

const results = { passed: 0, failed: 0, skipped: 0, tests: [] };
const output = document.getElementById('output');

function assert(condition, message) {
  if (!condition) throw new Error(message || 'Assertion failed');
}

function assertEqual(actual, expected, message) {
  if (actual !== expected) {
    throw new Error(`${message || 'assertEqual'}: expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}

function assertDeepEqual(actual, expected, message) {
  if (JSON.stringify(actual) !== JSON.stringify(expected)) {
    throw new Error(`${message || 'assertDeepEqual'}: expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}

function test(name, fn) {
  try {
    fn();
    results.passed++;
    results.tests.push({ name, status: 'pass' });
  } catch (e) {
    results.failed++;
    results.tests.push({ name, status: 'fail', error: e.message });
  }
}

function section(name) {
  results.tests.push({ name, status: 'section' });
}

// ═══════════════════════════════════════════════════════════════════
// Tests
// ═══════════════════════════════════════════════════════════════════

// ─── Constants ───
section('Constants & Event Types');

test('RESOURCE_CATEGORIES contains all 9 categories', () => {
  assertEqual(RESOURCE_CATEGORIES.length, 9);
  assert(RESOURCE_CATEGORIES.includes('housing'));
  assert(RESOURCE_CATEGORIES.includes('financial'));
  assert(RESOURCE_CATEGORIES.includes('transportation'));
  assert(RESOURCE_CATEGORIES.includes('food'));
  assert(RESOURCE_CATEGORIES.includes('health'));
  assert(RESOURCE_CATEGORIES.includes('employment'));
  assert(RESOURCE_CATEGORIES.includes('legal'));
  assert(RESOURCE_CATEGORIES.includes('education'));
  assert(RESOURCE_CATEGORIES.includes('general'));
});

test('RESOURCE_OPACITY has correct levels', () => {
  assertEqual(RESOURCE_OPACITY.SOVEREIGN, 0);
  assertEqual(RESOURCE_OPACITY.ATTESTED, 1);
  assertEqual(RESOURCE_OPACITY.CONTRIBUTED, 2);
  assertEqual(RESOURCE_OPACITY.PUBLISHED, 3);
});

test('RESOURCE_RELATION_TYPES contains all 5 types', () => {
  assertEqual(RESOURCE_RELATION_TYPES.length, 5);
  assert(RESOURCE_RELATION_TYPES.includes('operates'));
  assert(RESOURCE_RELATION_TYPES.includes('funds'));
  assert(RESOURCE_RELATION_TYPES.includes('refers_to'));
  assert(RESOURCE_RELATION_TYPES.includes('contributes_to'));
  assert(RESOURCE_RELATION_TYPES.includes('transfers'));
});

test('RESOURCE_ALLOC_STATUSES has 4 statuses', () => {
  assertEqual(RESOURCE_ALLOC_STATUSES.length, 4);
  assertDeepEqual(RESOURCE_ALLOC_STATUSES, ['active', 'consumed', 'expired', 'revoked']);
});

test('RESOURCE_LIFECYCLE_EVENTS has 5 events', () => {
  assertEqual(RESOURCE_LIFECYCLE_EVENTS.length, 5);
  assert(RESOURCE_LIFECYCLE_EVENTS.includes('returned'), 'Missing returned event');
});

test('RESOURCE_DEDUP_STATUSES has 3 statuses', () => {
  assertDeepEqual(RESOURCE_DEDUP_STATUSES, ['confirmed', 'attested_non_additive', 'unresolved']);
});

test('RESOURCE_DEDUP_LINK_TYPES has 3 types', () => {
  assertDeepEqual(RESOURCE_DEDUP_LINK_TYPES, ['subset', 'same', 'overlaps']);
});

// ─── ID Generation ───
section('ID Generation');

test('genResourceId produces unique IDs with correct prefix', () => {
  const id1 = genResourceId('rtype');
  const id2 = genResourceId('rtype');
  assert(id1.startsWith('rtype_'), `ID should start with prefix: ${id1}`);
  assert(id2.startsWith('rtype_'), `ID should start with prefix: ${id2}`);
  assert(id1 !== id2, 'IDs should be unique');
});

test('genResourceId works with various prefixes', () => {
  assert(genResourceId('ralloc').startsWith('ralloc_'));
  assert(genResourceId('rrel').startsWith('rrel_'));
  assert(genResourceId('prop').startsWith('prop_'));
});

// ─── Source / Provenance Building ───
section('Source & Provenance');

test('buildResourceSource sets level correctly', () => {
  const src = buildResourceSource('org');
  assertEqual(src.level, 'org');
  assert(src.adopted_at > 0, 'adopted_at should be set');
});

test('buildResourceSource includes propagation for network level', () => {
  const src = buildResourceSource('network', 'required');
  assertEqual(src.level, 'network');
  assertEqual(src.propagation, 'required');
});

test('buildResourceSource omits propagation for org level', () => {
  const src = buildResourceSource('org', 'standard');
  assertEqual(src.propagation, undefined);
});

test('buildResourceSource includes optional fields when provided', () => {
  const src = buildResourceSource('network', 'optional', 'CR-2024-01', '@admin:matrix.org', '!org:matrix.org');
  assertEqual(src.adopted_via, 'CR-2024-01');
  assertEqual(src.proposed_by, '@admin:matrix.org');
  assertEqual(src.origin_org, '!org:matrix.org');
});

test('buildResourceSource omits optional fields when not provided', () => {
  const src = buildResourceSource('org');
  assertEqual(src.adopted_via, undefined);
  assertEqual(src.proposed_by, undefined);
  assertEqual(src.origin_org, undefined);
});

// ─── Constraint Governance ───
section('Constraint Governance');

test('buildConstraintGovernance returns correct defaults', () => {
  const gov = buildConstraintGovernance();
  assertEqual(gov.propagation, 'optional');
  assertEqual(gov.adopted_via, null);
  assertEqual(gov.source_level, 'org');
  assertEqual(gov.divergence_allowed, true);
});

test('buildConstraintGovernance respects all parameters', () => {
  const gov = buildConstraintGovernance('network', 'required', 'CR-2024-05', false);
  assertEqual(gov.propagation, 'required');
  assertEqual(gov.adopted_via, 'CR-2024-05');
  assertEqual(gov.source_level, 'network');
  assertEqual(gov.divergence_allowed, false);
});

test('buildConstraintGovernance divergence_allowed defaults true even with explicit undefined', () => {
  const gov = buildConstraintGovernance('org', 'standard', null, undefined);
  assertEqual(gov.divergence_allowed, true);
});

// ─── Validate Allocation: Basic Cases ───
section('Validate Allocation — Basic');

const baseResourceType = {
  id: 'rtype_bus_voucher',
  name: 'Bus Voucher',
  category: 'transportation',
  unit: 'voucher',
  fungible: true,
  perishable: true,
  ttl_days: 90,
  constraints: null,
};

const baseAllocation = {
  resource_type_id: 'rtype_bus_voucher',
  allocated_to: '@client:matrix.org',
  quantity: 1,
};

test('validateAllocation passes with no constraints', () => {
  const result = validateAllocation(baseAllocation, baseResourceType, [], [], 'provider');
  assertEqual(result.valid, true);
  assertEqual(result.violations.length, 0);
});

test('validateAllocation passes with empty policies array', () => {
  const result = validateAllocation(baseAllocation, baseResourceType, null, null, 'provider');
  assertEqual(result.valid, true);
});

// ─── Validate Allocation: Eligible Roles ───
section('Validate Allocation — Eligible Roles');

test('validateAllocation rejects unauthorized role', () => {
  const rt = {
    ...baseResourceType,
    constraints: {
      eligible_roles: ['admin', 'case_manager'],
      governance: buildConstraintGovernance('network', 'required', 'CR-2024-01'),
    },
  };
  const result = validateAllocation(baseAllocation, rt, [], [], 'read_only');
  assertEqual(result.valid, false);
  assertEqual(result.violations.length, 1);
  assertEqual(result.violations[0].check, 'eligible_roles');
  assert(result.violations[0].message.includes('read_only'), 'Should mention the rejected role');
  assert(result.violations[0].governance !== null, 'Should include governance provenance');
});

test('validateAllocation accepts authorized role', () => {
  const rt = {
    ...baseResourceType,
    constraints: { eligible_roles: ['admin', 'provider'] },
  };
  const result = validateAllocation(baseAllocation, rt, [], [], 'provider');
  assertEqual(result.valid, true);
});

test('validateAllocation skips role check when eligible_roles is empty', () => {
  const rt = {
    ...baseResourceType,
    constraints: { eligible_roles: [] },
  };
  const result = validateAllocation(baseAllocation, rt, [], [], 'read_only');
  assertEqual(result.valid, true);
});

// ─── Validate Allocation: Max Per Client ───
section('Validate Allocation — Max Per Client');

test('validateAllocation enforces max_per_client cap', () => {
  const rt = {
    ...baseResourceType,
    constraints: {
      max_per_client: 2,
      period_days: 30,
      governance: buildConstraintGovernance('network', 'standard', 'CR-2024-03'),
    },
  };
  const existing = [
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@client:matrix.org', status: 'active', allocated_at: Date.now() - 1000 },
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@client:matrix.org', status: 'active', allocated_at: Date.now() - 2000 },
  ];
  const result = validateAllocation(baseAllocation, rt, [], existing, 'provider');
  assertEqual(result.valid, false);
  assertEqual(result.violations[0].check, 'max_per_client');
  assert(result.violations[0].message.includes('2'), 'Should mention the cap');
});

test('validateAllocation allows allocation within cap', () => {
  const rt = {
    ...baseResourceType,
    constraints: { max_per_client: 3, period_days: 30 },
  };
  const existing = [
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@client:matrix.org', status: 'active', allocated_at: Date.now() - 1000 },
  ];
  const result = validateAllocation(baseAllocation, rt, [], existing, 'provider');
  assertEqual(result.valid, true);
});

test('validateAllocation ignores consumed/expired allocations for cap', () => {
  const rt = {
    ...baseResourceType,
    constraints: { max_per_client: 1, period_days: 30 },
  };
  const existing = [
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@client:matrix.org', status: 'consumed', allocated_at: Date.now() - 1000 },
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@client:matrix.org', status: 'expired', allocated_at: Date.now() - 2000 },
  ];
  const result = validateAllocation(baseAllocation, rt, [], existing, 'provider');
  assertEqual(result.valid, true);
});

test('validateAllocation ignores allocations outside period window', () => {
  const rt = {
    ...baseResourceType,
    constraints: { max_per_client: 1, period_days: 30 },
  };
  const existing = [
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@client:matrix.org', status: 'active', allocated_at: Date.now() - (31 * 24 * 60 * 60 * 1000) },
  ];
  const result = validateAllocation(baseAllocation, rt, [], existing, 'provider');
  assertEqual(result.valid, true);
});

test('validateAllocation ignores allocations for other clients', () => {
  const rt = {
    ...baseResourceType,
    constraints: { max_per_client: 1, period_days: 30 },
  };
  const existing = [
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@other_client:matrix.org', status: 'active', allocated_at: Date.now() - 1000 },
  ];
  const result = validateAllocation(baseAllocation, rt, [], existing, 'provider');
  assertEqual(result.valid, true);
});

test('validateAllocation uses 365-day default period when period_days not set', () => {
  const rt = {
    ...baseResourceType,
    constraints: { max_per_client: 1 },
  };
  // Allocation from 200 days ago — within 365-day window
  const existing = [
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@client:matrix.org', status: 'active', allocated_at: Date.now() - (200 * 24 * 60 * 60 * 1000) },
  ];
  const result = validateAllocation(baseAllocation, rt, [], existing, 'provider');
  assertEqual(result.valid, false);
});

// ─── Validate Allocation: Approval ───
section('Validate Allocation — Approval');

test('validateAllocation rejects unapproved allocation when requires_approval is true', () => {
  const rt = {
    ...baseResourceType,
    constraints: {
      requires_approval: true,
      approver_roles: ['admin', 'case_manager'],
    },
  };
  const result = validateAllocation(baseAllocation, rt, [], [], 'provider');
  assertEqual(result.valid, false);
  assertEqual(result.violations[0].check, 'requires_approval');
  assert(result.violations[0].message.includes('admin'), 'Should list approver roles');
});

test('validateAllocation accepts approved allocation', () => {
  const rt = {
    ...baseResourceType,
    constraints: { requires_approval: true },
  };
  const alloc = {
    ...baseAllocation,
    approval: { approved_by: '@admin:matrix.org', approved_at: Date.now() },
  };
  const result = validateAllocation(alloc, rt, [], [], 'provider');
  assertEqual(result.valid, true);
});

test('validateAllocation respects approval_threshold — below threshold passes', () => {
  const rt = {
    ...baseResourceType,
    constraints: {
      requires_approval: true,
      approval_threshold: 100,
    },
  };
  const alloc = { ...baseAllocation, quantity: 50 };
  const result = validateAllocation(alloc, rt, [], [], 'provider');
  assertEqual(result.valid, true);
});

test('validateAllocation respects approval_threshold — above threshold fails without approval', () => {
  const rt = {
    ...baseResourceType,
    constraints: {
      requires_approval: true,
      approval_threshold: 100,
    },
  };
  const alloc = { ...baseAllocation, quantity: 150 };
  const result = validateAllocation(alloc, rt, [], [], 'provider');
  assertEqual(result.valid, false);
  assert(result.violations[0].message.includes('threshold'), 'Should mention threshold');
});

test('validateAllocation approval_threshold — above threshold passes with approval', () => {
  const rt = {
    ...baseResourceType,
    constraints: {
      requires_approval: true,
      approval_threshold: 100,
    },
  };
  const alloc = {
    ...baseAllocation,
    quantity: 150,
    approval: { approved_by: '@admin:matrix.org', approved_at: Date.now() },
  };
  const result = validateAllocation(alloc, rt, [], [], 'provider');
  assertEqual(result.valid, true);
});

// ─── Validate Allocation: Policy Merging ───
section('Validate Allocation — Policy Merging');

test('validateAllocation merges standalone policies with type constraints', () => {
  const rt = {
    ...baseResourceType,
    constraints: { max_per_client: 10 },
  };
  const policies = [{
    resource_type_id: 'rtype_bus_voucher',
    constraints: {
      max_per_client: 2, // more restrictive
      period_days: 7,
      governance: buildConstraintGovernance('network', 'required', 'CR-2024-06'),
    },
  }];
  const existing = [
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@client:matrix.org', status: 'active', allocated_at: Date.now() - 1000 },
    { resource_type_id: 'rtype_bus_voucher', allocated_to: '@client:matrix.org', status: 'active', allocated_at: Date.now() - 2000 },
  ];
  const result = validateAllocation(baseAllocation, rt, policies, existing, 'provider');
  assertEqual(result.valid, false);
  assertEqual(result.violations[0].check, 'max_per_client');
});

test('validateAllocation ignores policies for other resource types', () => {
  const rt = {
    ...baseResourceType,
    constraints: null,
  };
  const policies = [{
    resource_type_id: 'rtype_OTHER',
    constraints: { eligible_roles: ['admin'] },
  }];
  const result = validateAllocation(baseAllocation, rt, policies, [], 'provider');
  assertEqual(result.valid, true);
});

// ─── Validate Allocation: Multiple Violations ───
section('Validate Allocation — Multiple Violations');

test('validateAllocation reports all violations, not just first', () => {
  const rt = {
    ...baseResourceType,
    constraints: {
      eligible_roles: ['admin'],
      max_per_client: 0,
      requires_approval: true,
    },
  };
  const result = validateAllocation(baseAllocation, rt, [], [], 'provider');
  assertEqual(result.valid, false);
  // Should have all 3 violations: role, cap, approval
  assert(result.violations.length >= 2, `Expected multiple violations, got ${result.violations.length}`);
  const checks = result.violations.map(v => v.check);
  assert(checks.includes('eligible_roles'), 'Missing eligible_roles violation');
  assert(checks.includes('requires_approval'), 'Missing requires_approval violation');
});

// ─── Validate Allocation: Governance Provenance ───
section('Validate Allocation — Governance Provenance');

test('violations include governance metadata for contestability', () => {
  const gov = buildConstraintGovernance('network', 'required', 'CR-2024-03', false);
  const rt = {
    ...baseResourceType,
    constraints: {
      eligible_roles: ['admin'],
      governance: gov,
    },
  };
  const result = validateAllocation(baseAllocation, rt, [], [], 'provider');
  assertEqual(result.valid, false);
  const violation = result.violations[0];
  assertEqual(violation.governance.propagation, 'required');
  assertEqual(violation.governance.adopted_via, 'CR-2024-03');
  assertEqual(violation.governance.source_level, 'network');
  assertEqual(violation.governance.divergence_allowed, false);
});

test('violations include null governance when none set', () => {
  const rt = {
    ...baseResourceType,
    constraints: { eligible_roles: ['admin'] },
  };
  const result = validateAllocation(baseAllocation, rt, [], [], 'provider');
  assertEqual(result.violations[0].governance, null);
});

// ─── Data Structure Validation ───
section('Data Structure Shapes');

test('ResourceType shape has required fields', () => {
  const type = {
    id: 'rtype_test',
    name: 'Test Resource',
    category: 'general',
    unit: 'unit',
    fungible: true,
    perishable: false,
    tags: ['test'],
    source: buildResourceSource('org'),
    maturity: 'draft',
    constraints: null,
  };
  assert(type.id.startsWith('rtype_'));
  assert(RESOURCE_CATEGORIES.includes(type.category));
  assert(['draft', 'trial', 'normative', 'de_facto', 'deprecated'].includes(type.maturity));
  assert(type.source.level === 'org' || type.source.level === 'network');
});

test('ResourceRelation shape validates correctly', () => {
  const relation = {
    id: genResourceId('rrel'),
    resource_type_id: 'rtype_bus_voucher',
    holder: '!org:matrix.org',
    relation_type: 'operates',
    target: null,
    capacity: 100,
    available: 80,
    constraints_override: null,
    opacity: RESOURCE_OPACITY.SOVEREIGN,
    disclosed_fields: null,
    attested_to: null,
    established_at: Date.now(),
    established_by: '@admin:matrix.org',
    funding_source: null,
    notes: null,
    dedup: null,
  };
  assert(relation.id.startsWith('rrel_'));
  assert(RESOURCE_RELATION_TYPES.includes(relation.relation_type));
  assertEqual(relation.opacity, 0);
  assertEqual(relation.dedup, null);
});

test('ResourceAllocation shape validates correctly', () => {
  const allocation = {
    id: genResourceId('ralloc'),
    resource_type_id: 'rtype_bus_voucher',
    relation_id: 'rrel_abc',
    quantity: 3,
    unit: 'voucher',
    allocated_by: '@provider:matrix.org',
    allocated_to: '@client:matrix.org',
    org_id: '!org:matrix.org',
    status: 'active',
    allocated_at: Date.now(),
    expires_at: Date.now() + (90 * 24 * 60 * 60 * 1000),
    notes: null,
    approval: null,
  };
  assert(allocation.id.startsWith('ralloc_'));
  assert(RESOURCE_ALLOC_STATUSES.includes(allocation.status));
  assert(allocation.expires_at > allocation.allocated_at);
});

test('VaultResourceRecord shape is fully denormalized', () => {
  const vault = {
    allocation_id: 'ralloc_abc123',
    resource_type_id: 'rtype_bus_voucher',
    resource_name: 'Bus Voucher',           // denormalized string, NOT an ID
    quantity: 3,
    unit: 'voucher',
    provider_display_name: '@provider:matrix.org',  // denormalized
    org_display_name: 'Metro Services',             // denormalized
    allocated_at: Date.now(),
    status: 'active',
    notes: null,
    bridge_room_id: '!bridge:matrix.org',
    source_event_id: 'ralloc_abc123',
  };
  // Vault record must be human-readable without external references
  assert(typeof vault.resource_name === 'string', 'resource_name must be a plain string');
  assert(typeof vault.provider_display_name === 'string', 'provider_display_name must be denormalized');
  assert(typeof vault.org_display_name === 'string', 'org_display_name must be denormalized');
});

test('ResourceInventory shape tracks capacity correctly', () => {
  const inv = {
    resource_type_id: 'rtype_bus_voucher',
    relation_id: 'rrel_abc',
    total_capacity: 100,
    available: 70,
    allocated: 25,
    reserved: 5,
    last_restocked: Date.now(),
    last_updated: Date.now(),
  };
  assertEqual(inv.available + inv.allocated + inv.reserved, inv.total_capacity);
});

test('ResourceConstraints shape includes governance', () => {
  const constraints = {
    max_per_client: 5,
    period_days: 30,
    requires_approval: false,
    approval_threshold: null,
    approver_roles: ['admin'],
    eligible_roles: ['provider', 'case_manager'],
    governance: {
      propagation: 'standard',
      adopted_via: 'CR-2024-01',
      source_level: 'network',
      divergence_allowed: true,
    },
  };
  assert(constraints.governance.propagation !== undefined, 'Governance must include propagation');
  assert(constraints.governance.source_level !== undefined, 'Governance must include source_level');
});

// ─── Opacity Level Semantics ───
section('Opacity Semantics');

test('Opacity levels are ordered correctly', () => {
  assert(RESOURCE_OPACITY.SOVEREIGN < RESOURCE_OPACITY.ATTESTED);
  assert(RESOURCE_OPACITY.ATTESTED < RESOURCE_OPACITY.CONTRIBUTED);
  assert(RESOURCE_OPACITY.CONTRIBUTED < RESOURCE_OPACITY.PUBLISHED);
});

test('Default opacity is SOVEREIGN (0)', () => {
  assertEqual(RESOURCE_OPACITY.SOVEREIGN, 0);
});

// ─── Dedup Data Structures ───
section('Dedup Data Structures');

test('Dedup resolution states are all representable', () => {
  const confirmed = { linked_to: 'rrel_b', link_type: 'same', link_status: 'confirmed', link_resolved_by: '@admin:matrix.org', link_resolved_at: Date.now() };
  const attested = { linked_to: null, link_type: null, link_status: 'attested_non_additive', link_resolved_by: '@admin:matrix.org', link_resolved_at: Date.now() };
  const unresolved = { linked_to: 'rrel_b', link_type: 'overlaps', link_status: 'unresolved', link_resolved_by: null, link_resolved_at: null };

  assert(RESOURCE_DEDUP_STATUSES.includes(confirmed.link_status));
  assert(RESOURCE_DEDUP_STATUSES.includes(attested.link_status));
  assert(RESOURCE_DEDUP_STATUSES.includes(unresolved.link_status));
  assert(RESOURCE_DEDUP_LINK_TYPES.includes(confirmed.link_type));
  // attested_non_additive: linked_to is null (doesn't name which resource)
  assertEqual(attested.linked_to, null);
});

// ═══════════════════════════════════════════════════════════════════
// Render results
// ═══════════════════════════════════════════════════════════════════

let html = '';
for (const t of results.tests) {
  if (t.status === 'section') {
    html += `<h2>${t.name}</h2>`;
  } else if (t.status === 'pass') {
    html += `<div class="test"><span class="pass">PASS</span> ${t.name}</div>`;
  } else {
    html += `<div class="test"><span class="fail">FAIL</span> ${t.name}<pre>${t.error}</pre></div>`;
  }
}

const allPassed = results.failed === 0;
html += `<div class="summary ${allPassed ? 'ok' : 'fail'}">${results.passed} passed, ${results.failed} failed (${results.passed + results.failed} total)</div>`;

output.innerHTML = html;
document.title = allPassed
  ? `PASS (${results.passed}) — Khora Resource Tests`
  : `FAIL (${results.failed}) — Khora Resource Tests`;
</script>
</body>
</html>
